<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Virtual Watch Try-On</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(1); 
            z-index: 1;
        }

        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
            text-align: center;
        }

        .brand-ui {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 5;
            color: white;
            pointer-events: none;
        }
        
        .brand-ui h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .brand-ui p {
            margin: 5px 0 0;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        #camera-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background 0.3s;
        }
        
        #camera-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
        }
    </style>
    
    <!-- Three.js (Global Load) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
        
        <div id="loading">
            AI ëª¨ë¸ ë¡œë”© ì¤‘...<br>
            <span style="font-size: 0.8em; opacity: 0.8;">ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</span>
        </div>

        <button id="camera-toggle" title="ì¹´ë©”ë¼ ì „í™˜">ğŸ”„</button>

        <div class="brand-ui">
            <h1>LUXURY WATCH</h1>
            <p>Virtual Try-On Experience</p>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const loadingDiv = document.getElementById('loading');
        const toggleBtn = document.getElementById('camera-toggle');
        
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        
        let currentFacingMode = 'environment'; 

        let scene, camera, renderer;
        let watchGroup;
        let occlusionCylinder; 

        const targetPosition = new THREE.Vector3();
        const targetQuaternion = new THREE.Quaternion();
        let currentScale = 0.8; // í˜„ì¬ ìŠ¤ì¼€ì¼ ì €ì¥ìš© (ë³´ê°„ì„ ìœ„í•´)
        
        window.onload = async function() {
            try {
                await initThreeJS();
                await createHandLandmarker();
                startWebcam();
                
                toggleBtn.addEventListener('click', switchCamera);
            } catch (error) {
                console.error(error);
                loadingDiv.innerHTML = "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.<br>ì¹´ë©”ë¼ ê¶Œí•œì„ í™•ì¸í•˜ê±°ë‚˜ ë¡œì»¬ ì„œë²„(localhost)ì—ì„œ ì‹¤í–‰í•´ì£¼ì„¸ìš”.";
            }
        };

        function switchCamera() {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            startWebcam();
        }

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            loadingDiv.style.display = "none";
        }

        function initThreeJS() {
            scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            renderer.sortObjects = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            
            const spotLight = new THREE.SpotLight(0xffaa00, 2); 
            spotLight.position.set(-5, 5, 5);
            scene.add(spotLight);

            createProceduralWatch();
            createOcclusionMask(); 

            watchGroup.visible = false;
            occlusionCylinder.visible = false; 

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createProceduralWatch() {
            watchGroup = new THREE.Group();
            
            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                roughness: 0.3, 
                metalness: 0.8 
            });
            const blackLeatherMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.9 
            });
            const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            // --- ì‹œê³„ì¤„ (Strap) ---
            const wristRadius = 2.3; 
            const strapWidth = 1.6;  
            
            const strapGeo = new THREE.CylinderGeometry(wristRadius, wristRadius, strapWidth, 64, 1, true); 
            const strap = new THREE.Mesh(strapGeo, blackLeatherMat);
            strap.scale.set(1, 1, 0.85); 
            watchGroup.add(strap);

            // --- ì‹œê³„ ë³¸ì²´ (Case) ---
            const caseYOffset = (wristRadius * 0.85); 
            
            const caseGeo = new THREE.CylinderGeometry(1.8, 1.8, 0.4, 32);
            const watchCase = new THREE.Mesh(caseGeo, goldMaterial);
            watchCase.position.set(0, 0, caseYOffset); 
            watchCase.rotation.x = Math.PI / 2; 
            watchGroup.add(watchCase);

            // --- ì‹œê³„ íŒ (Dial) ---
            const dialGeo = new THREE.CylinderGeometry(1.6, 1.6, 0.42, 32);
            const dial = new THREE.Mesh(dialGeo, faceMaterial);
            dial.position.set(0, 0, caseYOffset);
            dial.rotation.x = Math.PI / 2;
            watchGroup.add(dial);

            // --- ì‹œê³„ ë°”ëŠ˜ ---
            const hourHandGeo = new THREE.BoxGeometry(0.1, 0.8, 0.05);
            const hourHand = new THREE.Mesh(hourHandGeo, blackLeatherMat);
            hourHand.position.set(0, 0, caseYOffset + 0.22);
            hourHand.rotation.z = Math.PI / 6;
            watchGroup.add(hourHand);

            const minHandGeo = new THREE.BoxGeometry(0.08, 1.2, 0.05);
            const minHand = new THREE.Mesh(minHandGeo, blackLeatherMat);
            minHand.position.set(0, 0, caseYOffset + 0.22);
            minHand.rotation.z = -Math.PI / 3;
            watchGroup.add(minHand);

            // --- ìš©ë‘ (Crown) ---
            const crownGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16);
            const crown = new THREE.Mesh(crownGeo, goldMaterial);
            crown.position.set(1.8, 0, caseYOffset); 
            crown.rotation.z = Math.PI / 2;
            watchGroup.add(crown);

            // --- ëŸ¬ê·¸ (Lugs) ---
            const lugGeo = new THREE.BoxGeometry(1.0, 0.4, 0.5);
            
            const lugTop = new THREE.Mesh(lugGeo, goldMaterial);
            lugTop.position.set(0, 1.7, caseYOffset - 0.2); 
            lugTop.rotation.x = -0.2;
            watchGroup.add(lugTop);

            const lugBottom = new THREE.Mesh(lugGeo, goldMaterial);
            lugBottom.position.set(0, -1.7, caseYOffset - 0.2); 
            lugBottom.rotation.x = 0.2;
            watchGroup.add(lugBottom);

            // --- ë²„í´ (Clasp) ---
            const claspGeo = new THREE.BoxGeometry(1.8, 0.8, 0.2);
            const clasp = new THREE.Mesh(claspGeo, goldMaterial);
            clasp.position.set(0, 0, -caseYOffset - 0.1); 
            watchGroup.add(clasp);

            scene.add(watchGroup);
        }

        function createOcclusionMask() {
            const occlusionGeo = new THREE.CylinderGeometry(2.2, 2.2, 6, 32); 
            const occlusionMat = new THREE.MeshBasicMaterial({ 
                colorWrite: false, 
                depthWrite: true,  
                depthTest: true,
            });
            occlusionCylinder = new THREE.Mesh(occlusionGeo, occlusionMat);
            occlusionCylinder.renderOrder = -1;
            occlusionCylinder.scale.set(1, 1, 0.82); 
            
            scene.add(occlusionCylinder);
        }

        function startWebcam() {
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const constraints = {
                    video: {
                        facingMode: currentFacingMode, 
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };

                if (currentFacingMode === 'user') {
                    video.style.transform = "scaleX(-1)";
                } else {
                    video.style.transform = "scaleX(1)";
                }

                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', predictWebcam);
                }).catch((err) => {
                    console.error("ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨:", err);
                    loadingDiv.innerText = "ì¹´ë©”ë¼ ì ‘ê·¼ ì˜¤ë¥˜: " + err.message;
                });
            } else {
                loadingDiv.innerText = "ì´ ë¸Œë¼ìš°ì €ëŠ” ì¹´ë©”ë¼ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
            }
        }

        async function predictWebcam() {
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                
                if (handLandmarker) {
                    const startTimeMs = performance.now();
                    const results = handLandmarker.detectForVideo(video, startTimeMs);
                    
                    if (results.landmarks && results.landmarks.length > 0) {
                        const landmarks = results.landmarks[0];
                        updateWatchPose(landmarks);
                        watchGroup.visible = true;
                        occlusionCylinder.visible = true; 
                    } else {
                        watchGroup.visible = false;
                        occlusionCylinder.visible = false; 
                    }
                }
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(predictWebcam);
        }

        function updateWatchPose(landmarks) {
            const wrist = landmarks[0];
            const indexMCP = landmarks[5];
            const pinkyMCP = landmarks[17];
            const middleMCP = landmarks[9];

            // 1. ìœ„ì¹˜ ê³„ì‚°
            let x = wrist.x;
            if (currentFacingMode === 'user') {
                x = 1 - x; 
            }
            
            const ndcX = (x * 2) - 1;
            const ndcY = -(wrist.y * 2 - 1); 
            
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5); 
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const finalPos = camera.position.clone().add(dir.multiplyScalar(18)); 

            targetPosition.copy(finalPos);
            watchGroup.position.lerp(targetPosition, 0.2);

            // 2. íšŒì „ ê³„ì‚°
            let wristX = wrist.x;
            let middleX = middleMCP.x;
            let indexX = indexMCP.x;
            let pinkyX = pinkyMCP.x;

            if (currentFacingMode === 'user') {
                wristX = 1 - wristX;
                middleX = 1 - middleX;
                indexX = 1 - indexX;
                pinkyX = 1 - pinkyX;
            }

            const v1 = new THREE.Vector3(
                middleX - wristX,
                -(middleMCP.y - wrist.y),
                -(middleMCP.z - wrist.z) * 2 
            ).normalize();

            const v2 = new THREE.Vector3(
                pinkyX - indexX,
                -(pinkyMCP.y - indexMCP.y),
                -(pinkyMCP.z - indexMCP.z) * 2
            ).normalize();

            const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
            
            const zAxis = normal;
            const yAxis = v1;
            const xAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();
            
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeBasis(xAxis, yAxis, zAxis);
            
            targetQuaternion.setFromRotationMatrix(rotationMatrix);
            watchGroup.quaternion.slerp(targetQuaternion, 0.2);

            // 3. ë™ì  ìŠ¤ì¼€ì¼ ì¡°ì • (ê±°ë¦¬ ë° ì† í¬ê¸° ê¸°ë°˜)
            // ê²€ì§€(5)ì™€ ìƒˆë¼(17) ê¸°ì €ë¶€ ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ì¸¡ì •
            const distX = indexX - pinkyX;
            const distY = indexMCP.y - pinkyMCP.y;
            // í™”ë©´ìƒì—ì„œì˜ 2D ê±°ë¦¬ (ì† ë„ˆë¹„)
            const handWidth = Math.sqrt(distX * distX + distY * distY);
            
            // ì ì ˆí•œ ë³´ì • ê³„ìˆ˜ (Scale Multiplier)
            // ì† ë„ˆë¹„ê°€ ëŒ€ëµ 0.1~0.15ì¼ ë•Œ ìŠ¤ì¼€ì¼ì´ 0.8 ì •ë„ ë‚˜ì˜¤ë„ë¡ ì„¤ì •
            // ê¸°ì¡´ 6.5 -> ì ˆë°˜ ì •ë„ì¸ 3.25ë¡œ ì¶•ì†Œ
            const scaleMultiplier = 3.25; 
            const targetScale = handWidth * scaleMultiplier;

            // ìŠ¤ì¼€ì¼ê°’ ë¶€ë“œëŸ½ê²Œ ë³´ê°„ (Lerp)
            currentScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);

            watchGroup.scale.set(currentScale, currentScale, currentScale);

            // 4. ì˜¤í´ë£¨ì „ ë§ˆìŠ¤í¬ ë™ê¸°í™”
            occlusionCylinder.position.copy(watchGroup.position);
            occlusionCylinder.quaternion.copy(watchGroup.quaternion);
            // ë§ˆìŠ¤í¬ ìŠ¤ì¼€ì¼ë„ ë™ì ìœ¼ë¡œ ë³€ê²½ (ê¸°ì¡´ ë‚´ë¶€ ë¹„ìœ¨ ìœ ì§€)
            occlusionCylinder.scale.set(currentScale, currentScale, currentScale * 0.82);
        }
    </script>
</body>
</html>

