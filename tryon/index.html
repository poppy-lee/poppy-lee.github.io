<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Virtual Watch Try-On</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(1); 
            z-index: 1;
        }

        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
            text-align: center;
        }

        .brand-ui {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 5;
            color: white;
            pointer-events: none;
        }
        
        .brand-ui h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .brand-ui p {
            margin: 5px 0 0;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        #camera-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background 0.3s;
        }
        
        #camera-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
        }
    </style>
    
    <!-- Three.js (Global Load) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
        
        <div id="loading">
            AI Î™®Îç∏ Î°úÎî© Ï§ë...<br>
            <span style="font-size: 0.8em; opacity: 0.8;">Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî.</span>
        </div>

        <button id="camera-toggle" title="Ïπ¥Î©îÎùº Ï†ÑÌôò">üîÑ</button>

        <div class="brand-ui">
            <h1>LUXURY WATCH</h1>
            <p>Virtual Try-On Experience</p>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const loadingDiv = document.getElementById('loading');
        const toggleBtn = document.getElementById('camera-toggle');
        
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        
        let currentFacingMode = 'environment'; 

        let scene, camera, renderer;
        let watchGroup;
        let occlusionCylinder; 

        const targetPosition = new THREE.Vector3();
        const targetQuaternion = new THREE.Quaternion();
        
        window.onload = async function() {
            try {
                await initThreeJS();
                await createHandLandmarker();
                startWebcam();
                
                toggleBtn.addEventListener('click', switchCamera);
            } catch (error) {
                console.error(error);
                loadingDiv.innerHTML = "Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.<br>Ïπ¥Î©îÎùº Í∂åÌïúÏùÑ ÌôïÏù∏ÌïòÍ±∞ÎÇò Î°úÏª¨ ÏÑúÎ≤Ñ(localhost)ÏóêÏÑú Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî.";
            }
        };

        function switchCamera() {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            startWebcam();
        }

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            loadingDiv.style.display = "none";
        }

        function initThreeJS() {
            scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Î†åÎçîÎßÅ ÏàúÏÑú Ï†ïÎ†¨ÏùÑ ÌôúÏÑ±Ìôî (Í∏∞Î≥∏Í∞í trueÏù¥ÏßÄÎßå Î™ÖÏãúÏ†Å ÌôïÏù∏)
            renderer.sortObjects = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            
            const spotLight = new THREE.SpotLight(0xffaa00, 2); 
            spotLight.position.set(-5, 5, 5);
            scene.add(spotLight);

            createProceduralWatch();
            createOcclusionMask(); 

            watchGroup.visible = false;
            occlusionCylinder.visible = false; 

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createProceduralWatch() {
            watchGroup = new THREE.Group();
            
            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                roughness: 0.3, 
                metalness: 0.8 
            });
            const blackLeatherMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.9 
            });
            const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            // --- ÏãúÍ≥ÑÏ§Ñ (Strap) ---
            const wristRadius = 2.3; // ÏÜêÎ™© Î∞òÏßÄÎ¶Ñ
            const strapWidth = 1.6;  // Ïä§Ìä∏Îû© ÎÑàÎπÑ
            
            const strapGeo = new THREE.CylinderGeometry(wristRadius, wristRadius, strapWidth, 64, 1, true); 
            const strap = new THREE.Mesh(strapGeo, blackLeatherMat);
            // ÌÉÄÏõêÌòïÏùÑ ÏúÑÌï¥ Ïä§ÏºÄÏùº Ï°∞Ï†ï
            strap.scale.set(1, 1, 0.85); 
            watchGroup.add(strap);

            // --- ÏãúÍ≥Ñ Î≥∏Ï≤¥ (Case) ---
            const caseYOffset = (wristRadius * 0.85); 
            
            const caseGeo = new THREE.CylinderGeometry(1.8, 1.8, 0.4, 32);
            const watchCase = new THREE.Mesh(caseGeo, goldMaterial);
            watchCase.position.set(0, 0, caseYOffset); 
            watchCase.rotation.x = Math.PI / 2; 
            watchGroup.add(watchCase);

            // --- ÏãúÍ≥Ñ Ìåê (Dial) ---
            const dialGeo = new THREE.CylinderGeometry(1.6, 1.6, 0.42, 32);
            const dial = new THREE.Mesh(dialGeo, faceMaterial);
            dial.position.set(0, 0, caseYOffset);
            dial.rotation.x = Math.PI / 2;
            watchGroup.add(dial);

            // --- ÏãúÍ≥Ñ Î∞îÎäò ---
            const hourHandGeo = new THREE.BoxGeometry(0.1, 0.8, 0.05);
            const hourHand = new THREE.Mesh(hourHandGeo, blackLeatherMat);
            hourHand.position.set(0, 0, caseYOffset + 0.22);
            hourHand.rotation.z = Math.PI / 6;
            watchGroup.add(hourHand);

            const minHandGeo = new THREE.BoxGeometry(0.08, 1.2, 0.05);
            const minHand = new THREE.Mesh(minHandGeo, blackLeatherMat);
            minHand.position.set(0, 0, caseYOffset + 0.22);
            minHand.rotation.z = -Math.PI / 3;
            watchGroup.add(minHand);

            // --- Ïö©Îëê (Crown) ---
            const crownGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16);
            const crown = new THREE.Mesh(crownGeo, goldMaterial);
            crown.position.set(1.8, 0, caseYOffset); 
            crown.rotation.z = Math.PI / 2;
            watchGroup.add(crown);

            // --- Îü¨Í∑∏ (Lugs) ---
            const lugGeo = new THREE.BoxGeometry(1.0, 0.4, 0.5);
            
            const lugTop = new THREE.Mesh(lugGeo, goldMaterial);
            lugTop.position.set(0, 1.7, caseYOffset - 0.2); 
            lugTop.rotation.x = -0.2;
            watchGroup.add(lugTop);

            const lugBottom = new THREE.Mesh(lugGeo, goldMaterial);
            lugBottom.position.set(0, -1.7, caseYOffset - 0.2); 
            lugBottom.rotation.x = 0.2;
            watchGroup.add(lugBottom);

            // --- Î≤ÑÌÅ¥ (Clasp) ---
            const claspGeo = new THREE.BoxGeometry(1.8, 0.8, 0.2);
            const clasp = new THREE.Mesh(claspGeo, goldMaterial);
            clasp.position.set(0, 0, -caseYOffset - 0.1); // Î∞òÎåÄÌé∏
            watchGroup.add(clasp);

            scene.add(watchGroup);
        }

        function createOcclusionMask() {
            // Ïã§Ï†ú ÏÜêÎ™©ÏùÑ ÌùâÎÇ¥ÎÇ¥Îäî Ìà¨Î™ÖÌïú ÏõêÌÜµ
            // ÍπäÏù¥ Î≤ÑÌçº(Depth Buffer)ÏóêÎäî Í∏∞Î°ùÎêòÏßÄÎßå ÌôîÎ©¥ÏóêÎäî Î≥¥Ïù¥ÏßÄ ÏïäÏùå
            const occlusionGeo = new THREE.CylinderGeometry(2.2, 2.2, 6, 32); 
            const occlusionMat = new THREE.MeshBasicMaterial({ 
                colorWrite: false, // ÌôîÎ©¥Ïóê ÏÉâÏÉÅÏùÑ Í∑∏Î¶¨ÏßÄ ÏïäÏùå
                depthWrite: true,  // ÍπäÏù¥Í∞íÏùÄ Í∏∞Î°ùÌï® (ÌïµÏã¨)
                depthTest: true,
            });
            occlusionCylinder = new THREE.Mesh(occlusionGeo, occlusionMat);
            
            // Ï§ëÏöî: renderOrderÎ•º -1Î°ú ÏÑ§Ï†ïÌïòÏó¨ Îã§Î•∏ Î™®Îì† Î¨ºÏ≤¥(Í∏∞Î≥∏Í∞í 0)Î≥¥Îã§ Î®ºÏ†Ä Í∑∏Î†§ÏßÄÍ≤å Ìï®
            // Ïù¥Î†áÍ≤å Ìï¥Ïïº ÎßàÏä§ÌÅ¨Í∞Ä Î®ºÏ†Ä Ìà¨Î™ÖÌïòÍ≤å Í∑∏Î†§ÏßÄÎ©¥ÏÑú ÍπäÏù¥ Î≤ÑÌçºÎ•º ÏÑ†Ï†êÌïòÍ≥†,
            // Í∑∏ Îí§Ïóê Í∑∏Î†§ÏßÄÎäî ÏãúÍ≥Ñ Î∂ÄÌíàÎì§Ïù¥ ÎßàÏä§ÌÅ¨ Îí§Ïóê ÏûàÏùÑ Í≤ΩÏö∞ Í∞ÄÎ†§ÏßÄÍ≤å Îê®.
            occlusionCylinder.renderOrder = -1;

            // ÏÜêÎ™© ÌòïÌÉú Î≥¥Ï†ï (ÏãúÍ≥ÑÏ§ÑÎ≥¥Îã§ ÏïΩÍ∞Ñ ÏïàÏ™ΩÏù¥ÏßÄÎßå Ï∂©Î∂ÑÌûà Ï±ÑÏö∞ÎèÑÎ°ù)
            occlusionCylinder.scale.set(1, 1, 0.82); 
            
            scene.add(occlusionCylinder);
        }

        function startWebcam() {
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const constraints = {
                    video: {
                        facingMode: currentFacingMode, 
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };

                if (currentFacingMode === 'user') {
                    video.style.transform = "scaleX(-1)";
                } else {
                    video.style.transform = "scaleX(1)";
                }

                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', predictWebcam);
                }).catch((err) => {
                    console.error("Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïã§Ìå®:", err);
                    loadingDiv.innerText = "Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïò§Î•ò: " + err.message;
                });
            } else {
                loadingDiv.innerText = "Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Ïπ¥Î©îÎùºÎ•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.";
            }
        }

        async function predictWebcam() {
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                
                if (handLandmarker) {
                    const startTimeMs = performance.now();
                    const results = handLandmarker.detectForVideo(video, startTimeMs);
                    
                    if (results.landmarks && results.landmarks.length > 0) {
                        const landmarks = results.landmarks[0];
                        updateWatchPose(landmarks);
                        watchGroup.visible = true;
                        occlusionCylinder.visible = true; 
                    } else {
                        watchGroup.visible = false;
                        occlusionCylinder.visible = false; 
                    }
                }
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(predictWebcam);
        }

        function updateWatchPose(landmarks) {
            const wrist = landmarks[0];
            const indexMCP = landmarks[5];
            const pinkyMCP = landmarks[17];
            const middleMCP = landmarks[9];

            // 1. ÏúÑÏπò Í≥ÑÏÇ∞
            let x = wrist.x;
            if (currentFacingMode === 'user') {
                x = 1 - x; 
            }
            
            const ndcX = (x * 2) - 1;
            const ndcY = -(wrist.y * 2 - 1); 
            
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5); 
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const finalPos = camera.position.clone().add(dir.multiplyScalar(18)); 

            targetPosition.copy(finalPos);
            watchGroup.position.lerp(targetPosition, 0.2);

            // 2. ÌöåÏ†Ñ Í≥ÑÏÇ∞
            let wristX = wrist.x;
            let middleX = middleMCP.x;
            let indexX = indexMCP.x;
            let pinkyX = pinkyMCP.x;

            if (currentFacingMode === 'user') {
                wristX = 1 - wristX;
                middleX = 1 - middleX;
                indexX = 1 - indexX;
                pinkyX = 1 - pinkyX;
            }

            // YÏ∂ï: ÌåîÎöù Î∞©Ìñ•
            const v1 = new THREE.Vector3(
                middleX - wristX,
                -(middleMCP.y - wrist.y),
                -(middleMCP.z - wrist.z) * 2 
            ).normalize();

            // XÏ∂ï: ÏÜêÎ∞îÎã• Í∞ÄÎ°ú Î∞©Ìñ•
            const v2 = new THREE.Vector3(
                pinkyX - indexX,
                -(pinkyMCP.y - indexMCP.y),
                -(pinkyMCP.z - indexMCP.z) * 2
            ).normalize();

            // ZÏ∂ï: ÏÜêÎì± Î≤ïÏÑ† Î≤°ÌÑ∞
            const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
            
            const zAxis = normal;
            const yAxis = v1;
            const xAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();
            
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeBasis(xAxis, yAxis, zAxis);
            
            targetQuaternion.setFromRotationMatrix(rotationMatrix);
            watchGroup.quaternion.slerp(targetQuaternion, 0.2);

            // 3. Ïä§ÏºÄÏùº Ï°∞Ï†ï
            const baseScale = 0.8; 
            watchGroup.scale.set(baseScale, baseScale, baseScale);

            // 4. Ïò§ÌÅ¥Î£®Ï†Ñ ÎßàÏä§ÌÅ¨ ÎèôÍ∏∞Ìôî
            occlusionCylinder.position.copy(watchGroup.position);
            occlusionCylinder.quaternion.copy(watchGroup.quaternion);
            // ÏÜê ÌÅ¨Í∏∞ Î≥ÄÌôî(baseScale)Îßå Î∞òÏòÅÌïòÍ≥†, ÎÇ¥Î∂Ä ÎπÑÏú®(0.82 Îì±)ÏùÄ Ïú†ÏßÄ
            occlusionCylinder.scale.set(baseScale, baseScale, baseScale * 0.82);
        }
    </script>
</body>
</html>

