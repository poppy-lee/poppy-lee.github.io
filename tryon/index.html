<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Virtual Watch Try-On</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(1); 
            z-index: 1;
        }

        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
            text-align: center;
        }

        .brand-ui {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 5;
            color: white;
            pointer-events: none;
        }
        
        .brand-ui h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .brand-ui p {
            margin: 5px 0 0;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        #camera-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background 0.3s;
        }
        
        #camera-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
        }
    </style>
    
    <!-- Three.js (Global Load) --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
        
        <div id="loading">
            AI Î™®Îç∏ Î°úÎî© Ï§ë...<br>
            <span style="font-size: 0.8em; opacity: 0.8;">Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî.</span>
        </div>

        <button id="camera-toggle" title="Ïπ¥Î©îÎùº Ï†ÑÌôò">üîÑ</button>

        <div class="brand-ui">
            <h1>LUXURY WATCH</h1>
            <p>Virtual Try-On Experience</p>
        </div>
    </div>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const loadingDiv = document.getElementById('loading');
        const toggleBtn = document.getElementById('camera-toggle');
        
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        
        let currentFacingMode = 'environment'; 

        let scene, camera, renderer;
        let watchGroup;
        let occlusionCylinder; // Ïò§ÌÅ¥Î£®Ï†Ñ ÎßàÏä§ÌÅ¨

        const targetPosition = new THREE.Vector3();
        const targetQuaternion = new THREE.Quaternion();
        
        window.onload = async function() {
            try {
                await initThreeJS();
                await createHandLandmarker();
                startWebcam();
                
                toggleBtn.addEventListener('click', switchCamera);
            } catch (error) {
                console.error(error);
                loadingDiv.innerHTML = "Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.<br>Ïπ¥Î©îÎùº Í∂åÌïúÏùÑ ÌôïÏù∏ÌïòÍ±∞ÎÇò Î°úÏª¨ ÏÑúÎ≤Ñ(localhost)ÏóêÏÑú Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî.";
            }
        };

        function switchCamera() {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            startWebcam();
        }

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            loadingDiv.style.display = "none";
        }

        function initThreeJS() {
            scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            
            const spotLight = new THREE.SpotLight(0xffaa00, 2); 
            spotLight.position.set(-5, 5, 5);
            scene.add(spotLight);

            createProceduralWatch();
            createOcclusionMask(); // Ïò§ÌÅ¥Î£®Ï†Ñ ÎßàÏä§ÌÅ¨ ÏÉùÏÑ±

            watchGroup.visible = false;
            occlusionCylinder.visible = false; // ÏãúÍ≥ÑÏôÄ Ìï®Íªò Í∞ÄÎ¶º ÎßàÏä§ÌÅ¨ÎèÑ Ïà®ÍπÄ

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createProceduralWatch() {
            watchGroup = new THREE.Group();
            
            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                roughness: 0.3, 
                metalness: 0.8 
            });
            const blackLeatherMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.9 
            });
            const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            // ÏãúÍ≥Ñ Î≥∏Ï≤¥ (Case)
            const caseGeo = new THREE.CylinderGeometry(1.8, 1.8, 0.4, 32);
            const watchCase = new THREE.Mesh(caseGeo, goldMaterial);
            watchCase.rotation.x = Math.PI / 2;
            watchGroup.add(watchCase);

            // ÏãúÍ≥Ñ Ìåê (Dial)
            const dialGeo = new THREE.CylinderGeometry(1.6, 1.6, 0.42, 32);
            const dial = new THREE.Mesh(dialGeo, faceMaterial);
            dial.rotation.x = Math.PI / 2;
            watchGroup.add(dial);

            // ÏãúÍ≥Ñ Î∞îÎäò (Hands)
            const hourHandGeo = new THREE.BoxGeometry(0.1, 0.8, 0.05);
            const hourHand = new THREE.Mesh(hourHandGeo, blackLeatherMat);
            hourHand.position.z = 0.22;
            hourHand.rotation.z = Math.PI / 6;
            watchGroup.add(hourHand);

            const minHandGeo = new THREE.BoxGeometry(0.08, 1.2, 0.05);
            const minHand = new THREE.Mesh(minHandGeo, blackLeatherMat);
            minHand.position.z = 0.22;
            minHand.rotation.z = -Math.PI / 3;
            watchGroup.add(minHand);

            // Ïö©Îëê (Crown)
            const crownGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16);
            const crown = new THREE.Mesh(crownGeo, goldMaterial);
            crown.position.x = 1.8;
            crown.rotation.z = Math.PI / 2;
            watchGroup.add(crown);

            // ÏãúÍ≥Ñ Ïä§Ìä∏Îû© (Îçî ÏñáÍ≥† ÏÜêÎ™©Ïóê Í∞êÍ∏∞Îäî ÌòïÌÉúÎ°ú)
            // ÏÉÅÎã® Ïä§Ìä∏Îû© (ÏãúÍ≥ÑÏ§Ñ ÎÑàÎπÑ 1.4, Í∏∏Ïù¥ 3.5, ÎëêÍªò 0.1)
            const strapUpperGeo = new THREE.CylinderGeometry(0.7, 0.7, 3.5, 16, 1, false, 0, Math.PI); // Î∞òÏõêÌÜµ
            const upperStrap = new THREE.Mesh(strapUpperGeo, blackLeatherMat);
            upperStrap.rotation.z = Math.PI / 2; // ÏòÜÏúºÎ°ú ÎàïÌûò
            upperStrap.position.set(0, 2.8, 0); // ÏãúÍ≥ÑÏóêÏÑú ÏúÑÎ°ú Ïù¥Îèô
            watchGroup.add(upperStrap);

            // ÌïòÎã® Ïä§Ìä∏Îû©
            const strapLowerGeo = new THREE.CylinderGeometry(0.7, 0.7, 3.5, 16, 1, false, 0, Math.PI); // Î∞òÏõêÌÜµ
            const lowerStrap = new THREE.Mesh(strapLowerGeo, blackLeatherMat);
            lowerStrap.rotation.z = -Math.PI / 2; // ÏòÜÏúºÎ°ú ÎàïÌûò
            lowerStrap.position.set(0, -2.8, 0); // ÏãúÍ≥ÑÏóêÏÑú ÏïÑÎûòÎ°ú Ïù¥Îèô
            watchGroup.add(lowerStrap);

            scene.add(watchGroup);
        }

        // ÏÜêÎ™©ÏùÑ Í∞ÄÎ¶¨Îäî Ïò§ÌÅ¥Î£®Ï†Ñ ÎßàÏä§ÌÅ¨ ÏÉùÏÑ±
        function createOcclusionMask() {
            // ÏÜêÎ™©Ïùò ÌòïÌÉúÎ•º ÎåÄÎûµÏ†ÅÏúºÎ°ú ÎÇòÌÉÄÎÇº Ïàò ÏûàÎäî ÏñáÏùÄ ÏõêÌÜµ
            const occlusionGeo = new THREE.CylinderGeometry(2, 2, 4, 32); 
            const occlusionMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, // ÎîîÎ≤ÑÍπÖÏö© Îπ®Í∞ÑÏÉâ (Ïã§Ï†úÎ°úÎäî Î≥¥Ïù¥ÏßÄ ÏïäÏùå)
                colorWrite: false, // ÌôîÎ©¥Ïóê ÏÉâÏÉÅÏùÑ Í∑∏Î¶¨ÏßÄ ÏïäÏùå
                depthWrite: true,  // ÍπäÏù¥ Î≤ÑÌçºÏóêÎäî Í∏∞Î°ùÌïòÏó¨ Îí§Ïùò Ïò§Î∏åÏ†ùÌä∏Î•º Í∞ÄÎ¶º
                depthTest: true,
                transparent: true,
                opacity: 0 // Ïã§Ï†úÎ°úÎäî Ìà¨Î™ÖÌïòÍ≤å
            });
            occlusionCylinder = new THREE.Mesh(occlusionGeo, occlusionMat);
            occlusionCylinder.rotation.x = Math.PI / 2; // ÏÜêÎ™©Ïóê Í∞êÍ∏∞ÎèÑÎ°ù ÌöåÏ†Ñ
            scene.add(occlusionCylinder);
        }

        function startWebcam() {
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const constraints = {
                    video: {
                        facingMode: currentFacingMode, 
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };

                if (currentFacingMode === 'user') {
                    video.style.transform = "scaleX(-1)";
                } else {
                    video.style.transform = "scaleX(1)";
                }

                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', predictWebcam);
                }).catch((err) => {
                    console.error("Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïã§Ìå®:", err);
                    loadingDiv.innerText = "Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïò§Î•ò: " + err.message;
                });
            } else {
                loadingDiv.innerText = "Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Ïπ¥Î©îÎùºÎ•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.";
            }
        }

        async function predictWebcam() {
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                
                if (handLandmarker) {
                    const startTimeMs = performance.now();
                    const results = handLandmarker.detectForVideo(video, startTimeMs);
                    
                    if (results.landmarks && results.landmarks.length > 0) {
                        const landmarks = results.landmarks[0];
                        updateWatchPose(landmarks);
                        watchGroup.visible = true;
                        occlusionCylinder.visible = true; // ÏÜêÏù¥ Î≥¥Ïù¥Î©¥ ÎßàÏä§ÌÅ¨ÎèÑ Î≥¥Ïù¥Í≤å
                    } else {
                        watchGroup.visible = false;
                        occlusionCylinder.visible = false; // ÏÜêÏù¥ ÏóÜÏúºÎ©¥ ÎßàÏä§ÌÅ¨ÎèÑ Ïà®ÍπÄ
                    }
                }
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(predictWebcam);
        }

        function updateWatchPose(landmarks) {
            const wrist = landmarks[0];
            const indexMCP = landmarks[5];
            const pinkyMCP = landmarks[17];
            const middleMCP = landmarks[9];

            // 1. ÏúÑÏπò Í≥ÑÏÇ∞ (Position)
            let x = wrist.x;
            if (currentFacingMode === 'user') {
                x = 1 - x; 
            }
            
            const ndcX = (x * 2) - 1;
            const ndcY = -(wrist.y * 2 - 1); 
            
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5); 
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const finalPos = camera.position.clone().add(dir.multiplyScalar(18)); 

            targetPosition.copy(finalPos);
            watchGroup.position.lerp(targetPosition, 0.2);

            // 2. ÌöåÏ†Ñ Í≥ÑÏÇ∞ (Rotation)
            let wristX = wrist.x;
            let middleX = middleMCP.x;
            let indexX = indexMCP.x;
            let pinkyX = pinkyMCP.x;

            if (currentFacingMode === 'user') {
                wristX = 1 - wristX;
                middleX = 1 - middleX;
                indexX = 1 - indexX;
                pinkyX = 1 - pinkyX;
            }

            const v1 = new THREE.Vector3(
                middleX - wristX,
                -(middleMCP.y - wrist.y),
                -(middleMCP.z - wrist.z) * 2 
            ).normalize();

            const v2 = new THREE.Vector3(
                pinkyX - indexX,
                -(pinkyMCP.y - indexMCP.y),
                -(pinkyMCP.z - indexMCP.z) * 2
            ).normalize();

            const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
            
            const zAxis = normal;
            const yAxis = v1;
            const xAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();
            
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeBasis(xAxis, yAxis, zAxis);
            
            targetQuaternion.setFromRotationMatrix(rotationMatrix);
            watchGroup.quaternion.slerp(targetQuaternion, 0.2);

            // 3. Ïä§ÏºÄÏùº Ï°∞Ï†ï (ÏÜê ÌÅ¨Í∏∞Ïóê Îî∞Î•∏)
            const baseScale = 0.8; 
            watchGroup.scale.set(baseScale, baseScale, baseScale);

            // 4. Ïò§ÌÅ¥Î£®Ï†Ñ ÎßàÏä§ÌÅ¨ ÏúÑÏπò Î∞è ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏
            // ÏãúÍ≥ÑÏôÄ ÎèôÏùºÌïú ÏúÑÏπò Î∞è ÌöåÏ†ÑÏùÑ Í≥µÏú†ÌïòÎèÑÎ°ù ÏÑ§Ï†ï
            occlusionCylinder.position.copy(watchGroup.position);
            occlusionCylinder.quaternion.copy(watchGroup.quaternion);
            occlusionCylinder.scale.copy(watchGroup.scale);
        }
    </script>
</body>
</html>

