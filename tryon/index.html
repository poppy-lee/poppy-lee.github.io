<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Virtual Watch Try-On</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* Ï¥àÍ∏∞Í∞íÏùÄ Ïä§ÌÅ¨Î¶ΩÌä∏ÏóêÏÑú Ï†úÏñ¥Ìï©ÎãàÎã§ (ÌõÑÎ©¥: Ï†ïÎ∞©Ìñ•, Ï†ÑÎ©¥: Ï¢åÏö∞Î∞òÏ†Ñ) */
            transform: scaleX(1); 
            z-index: 1;
        }

        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
            text-align: center;
        }

        .brand-ui {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 5;
            color: white;
            pointer-events: none;
        }
        
        .brand-ui h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .brand-ui p {
            margin: 5px 0 0;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Ïπ¥Î©îÎùº Ï†ÑÌôò Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        #camera-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: background 0.3s;
        }
        
        #camera-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
        }
    </style>
    
    <!-- Three.js (Global Load) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
        
        <div id="loading">
            AI Î™®Îç∏ Î°úÎî© Ï§ë...<br>
            <span style="font-size: 0.8em; opacity: 0.8;">Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî.</span>
        </div>

        <!-- Ïπ¥Î©îÎùº Ï†ÑÌôò Î≤ÑÌäº -->
        <button id="camera-toggle" title="Ïπ¥Î©îÎùº Ï†ÑÌôò">üîÑ</button>

        <div class="brand-ui">
            <h1>LUXURY WATCH</h1>
            <p>Virtual Try-On Experience</p>
        </div>
    </div>

    <!-- type="module"ÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ ES6 import Íµ¨Î¨∏ÏùÑ ÏßÄÏõêÌïòÎèÑÎ°ù Ìï® -->
    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const loadingDiv = document.getElementById('loading');
        const toggleBtn = document.getElementById('camera-toggle');
        
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        
        // Í∏∞Î≥∏ Ïπ¥Î©îÎùº ÏÑ§Ï†ï: environment (ÌõÑÎ©¥)
        let currentFacingMode = 'environment'; 

        // Three.js Î≥ÄÏàòÎì§
        let scene, camera, renderer;
        let watchGroup;
        
        const targetPosition = new THREE.Vector3();
        const targetQuaternion = new THREE.Quaternion();
        
        // Ï¥àÍ∏∞Ìôî ÏãúÏûë
        window.onload = async function() {
            try {
                await initThreeJS();
                await createHandLandmarker();
                startWebcam(); // Ï¥àÍ∏∞ Ïã§Ìñâ
                
                // Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
                toggleBtn.addEventListener('click', switchCamera);
            } catch (error) {
                console.error(error);
                loadingDiv.innerHTML = "Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.<br>Ïπ¥Î©îÎùº Í∂åÌïúÏùÑ ÌôïÏù∏ÌïòÍ±∞ÎÇò Î°úÏª¨ ÏÑúÎ≤Ñ(localhost)ÏóêÏÑú Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî.";
            }
        };

        // Ïπ¥Î©îÎùº Ï†ÑÌôò Ìï®Ïàò
        function switchCamera() {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            startWebcam();
        }

        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            loadingDiv.style.display = "none";
        }

        function initThreeJS() {
            scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            
            const spotLight = new THREE.SpotLight(0xffaa00, 2); 
            spotLight.position.set(-5, 5, 5);
            scene.add(spotLight);

            createProceduralWatch();
            watchGroup.visible = false;

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createProceduralWatch() {
            watchGroup = new THREE.Group();
            
            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                roughness: 0.3, 
                metalness: 0.8 
            });
            const blackLeatherMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.9 
            });
            const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            const caseGeo = new THREE.CylinderGeometry(1.8, 1.8, 0.4, 32);
            const watchCase = new THREE.Mesh(caseGeo, goldMaterial);
            watchCase.rotation.x = Math.PI / 2;
            watchGroup.add(watchCase);

            const dialGeo = new THREE.CylinderGeometry(1.6, 1.6, 0.42, 32);
            const dial = new THREE.Mesh(dialGeo, faceMaterial);
            dial.rotation.x = Math.PI / 2;
            watchGroup.add(dial);

            const hourHandGeo = new THREE.BoxGeometry(0.1, 0.8, 0.05);
            const hourHand = new THREE.Mesh(hourHandGeo, blackLeatherMat);
            hourHand.position.z = 0.22;
            hourHand.rotation.z = Math.PI / 6;
            watchGroup.add(hourHand);

            const minHandGeo = new THREE.BoxGeometry(0.08, 1.2, 0.05);
            const minHand = new THREE.Mesh(minHandGeo, blackLeatherMat);
            minHand.position.z = 0.22;
            minHand.rotation.z = -Math.PI / 3;
            watchGroup.add(minHand);

            const strapGeo = new THREE.BoxGeometry(1.4, 2.5, 0.2);
            const upperStrap = new THREE.Mesh(strapGeo, blackLeatherMat);
            upperStrap.position.y = 2.2;
            upperStrap.rotation.x = -0.2; 
            watchGroup.add(upperStrap);

            const lowerStrap = new THREE.Mesh(strapGeo, blackLeatherMat);
            lowerStrap.position.y = -2.2;
            lowerStrap.rotation.x = 0.2;
            watchGroup.add(lowerStrap);
            
            const crownGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16);
            const crown = new THREE.Mesh(crownGeo, goldMaterial);
            crown.position.x = 1.8;
            crown.rotation.z = Math.PI / 2;
            watchGroup.add(crown);

            scene.add(watchGroup);
        }

        function startWebcam() {
            // Í∏∞Ï°¥ Ïä§Ìä∏Î¶ºÏù¥ ÏûàÎã§Î©¥ Ï§ëÏßÄ (Ïπ¥Î©îÎùº Ï†ÑÌôò Ïãú ÌïÑÏöî)
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const constraints = {
                    video: {
                        facingMode: currentFacingMode, // ÌòÑÏû¨ ÏÑ§Ï†ïÎêú Ïπ¥Î©îÎùº Î™®Îìú ÏÇ¨Ïö©
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };

                // Ïπ¥Î©îÎùº Î™®ÎìúÏóê Îî∞Î•∏ CSS Î≥ÄÌôò Ï≤òÎ¶¨
                // Ï†ÑÎ©¥ Ïπ¥Î©îÎùº(user)Îäî Í±∞Ïö∏ Î™®ÎìúÎ°ú Ï¢åÏö∞ Î∞òÏ†Ñ ÌïÑÏöî
                // ÌõÑÎ©¥ Ïπ¥Î©îÎùº(environment)Îäî Î∞òÏ†Ñ ÏóÜÏù¥ Í∑∏ÎåÄÎ°ú ÌëúÏãú
                if (currentFacingMode === 'user') {
                    video.style.transform = "scaleX(-1)";
                } else {
                    video.style.transform = "scaleX(1)";
                }

                navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', predictWebcam);
                }).catch((err) => {
                    console.error("Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïã§Ìå®:", err);
                    loadingDiv.innerText = "Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïò§Î•ò: " + err.message;
                });
            } else {
                loadingDiv.innerText = "Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Ïπ¥Î©îÎùºÎ•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.";
            }
        }

        async function predictWebcam() {
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                
                if (handLandmarker) {
                    const startTimeMs = performance.now();
                    const results = handLandmarker.detectForVideo(video, startTimeMs);
                    
                    if (results.landmarks && results.landmarks.length > 0) {
                        const landmarks = results.landmarks[0];
                        updateWatchPose(landmarks);
                        watchGroup.visible = true;
                    } else {
                         watchGroup.visible = false;
                    }
                }
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(predictWebcam);
        }

        function updateWatchPose(landmarks) {
            const wrist = landmarks[0];
            const indexMCP = landmarks[5];
            const pinkyMCP = landmarks[17];
            const middleMCP = landmarks[9];

            // 1. ÏúÑÏπò Í≥ÑÏÇ∞
            // ÎØ∏ÎîîÏñ¥ÌååÏù¥ÌîÑ Ï¢åÌëú (0~1)
            let x = wrist.x;
            
            // Ï†ÑÎ©¥ Ïπ¥Î©îÎùº(Í±∞Ïö∏Î™®Îìú)Ïùº ÎïåÎßå XÏ¢åÌëú Î∞òÏ†Ñ Í≥ÑÏÇ∞Ïù¥ ÌïÑÏöîÌï®
            // ÌõÑÎ©¥ Ïπ¥Î©îÎùºÎäî ÏûàÎäî Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
            if (currentFacingMode === 'user') {
                x = 1 - x; 
            }
            
            // NDC Ï¢åÌëúÍ≥ÑÎ°ú Î≥ÄÌôò (-1 ~ 1)
            // Three.jsÎäî Ï§ëÏïôÏù¥ (0,0)
            const ndcX = (x * 2) - 1;
            const ndcY = -(wrist.y * 2 - 1); // YÎäî Ìï≠ÏÉÅ ÏÉÅÌïò Î∞òÏ†Ñ ÌïÑÏöî (Ï∫îÎ≤ÑÏä§ Ï¢åÌëúÍ≥Ñ vs WebGL Ï¢åÌëúÍ≥Ñ)

            // ÍπäÏù¥ Ï∂îÏ†ï
            // Ï†ÑÎ©¥ Ïπ¥Î©îÎùºÏôÄ ÌõÑÎ©¥ Ïπ¥Î©îÎùºÎäî ÌôîÍ∞Å Ï∞®Ïù¥Î°ú Ïù∏Ìï¥ Í±∞Î¶¨Í∞êÏù¥ Îã§Î•º Ïàò ÏûàÏñ¥ Î≥¥Ï†ïÏù¥ ÌïÑÏöîÌï† Ïàò ÏûàÏùå
            const p1 = new THREE.Vector3(indexMCP.x, indexMCP.y, 0);
            const p2 = new THREE.Vector3(pinkyMCP.x, pinkyMCP.y, 0);
            const handWidth = p1.distanceTo(p2); 
            
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5); 
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const finalPos = camera.position.clone().add(dir.multiplyScalar(18)); 

            targetPosition.copy(finalPos);
            watchGroup.position.lerp(targetPosition, 0.2);

            // 2. ÌöåÏ†Ñ Í≥ÑÏÇ∞
            // ÌöåÏ†Ñ Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú X Ï¢åÌëú Ï≤òÎ¶¨ÎèÑ Ïπ¥Î©îÎùº Î™®ÎìúÏóê Îî∞Îùº Îã¨ÎùºÏßê
            let wristX = wrist.x;
            let middleX = middleMCP.x;
            let indexX = indexMCP.x;
            let pinkyX = pinkyMCP.x;

            if (currentFacingMode === 'user') {
                wristX = 1 - wristX;
                middleX = 1 - middleX;
                indexX = 1 - indexX;
                pinkyX = 1 - pinkyX;
            }

            // Î≤°ÌÑ∞ V1: ÏÜêÎ™© -> Ï§ëÏßÄ
            const v1 = new THREE.Vector3(
                middleX - wristX,
                -(middleMCP.y - wrist.y),
                -(middleMCP.z - wrist.z) * 2 
            ).normalize();

            // Î≤°ÌÑ∞ V2: Í≤ÄÏßÄ -> ÏÉàÎÅº
            const v2 = new THREE.Vector3(
                pinkyX - indexX,
                -(pinkyMCP.y - indexMCP.y),
                -(pinkyMCP.z - indexMCP.z) * 2
            ).normalize();

            const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
            
            const zAxis = normal;
            const yAxis = v1;
            const xAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();
            
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeBasis(xAxis, yAxis, zAxis);
            
            targetQuaternion.setFromRotationMatrix(rotationMatrix);
            watchGroup.quaternion.slerp(targetQuaternion, 0.2);

            const baseScale = 0.8; 
            watchGroup.scale.set(baseScale, baseScale, baseScale);
        }
    </script>
</body>
</html>

