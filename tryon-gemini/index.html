<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>AR Watch - Rear Camera (Env Mode)</title>

    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        font-family: sans-serif;
      }

      .container {
        position: relative;
        width: 100%;
        height: 100%;
      }

      /* 비디오는 숨기고 캔버스만 보여줍니다 */
      .input_video {
        display: none;
      }

      /* 결과 화면 캔버스 */
      .output_canvas {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        object-fit: cover; /* 화면 꽉 채우기 */

        /* [변경점] 후면 카메라이므로 거울모드(scaleX -1)를 제거했습니다. */
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 1.2rem;
        z-index: 10;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px 20px;
        border-radius: 8px;
        pointer-events: none;
      }

      /* 모바일 디버깅용 정보 */
      .debug-info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: lime;
        font-size: 12px;
        z-index: 20;
        background: rgba(0, 0, 0, 0.5);
        padding: 4px;
      }
    </style>

    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div class="container">
      <div class="loading" id="loading-text">Camera Starting...</div>
      <div class="debug-info" id="debug-text">Initializing...</div>
      <video class="input_video" playsinline muted autoplay></video>
      <canvas class="output_canvas"></canvas>
    </div>

    <script>
      const videoElement = document.querySelector(".input_video");
      const canvasElement = document.querySelector(".output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const loadingText = document.getElementById("loading-text");
      const debugText = document.getElementById("debug-text");

      // 화면 크기 맞춤
      function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // MediaPipe 결과 콜백
      function onResults(results) {
        loadingText.style.display = "none";
        debugText.innerText = `Hand Detected: ${
          results.multiHandLandmarks.length > 0 ? "Yes" : "No"
        }`;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        // 비디오 이미지를 캔버스 크기에 맞춰 그리기 (object-fit: cover 효과 흉내)
        // 실제 AR 구현 시에는 비율 계산이 더 정교해야 하지만, 지금은 꽉 채워 그립니다.
        canvasCtx.drawImage(
          results.image,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );

        if (results.multiHandLandmarks) {
          for (const landmarks of results.multiHandLandmarks) {
            // 기본 뼈대 그리기
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
              color: "#00FF00",
              lineWidth: 2,
            });
            drawLandmarks(canvasCtx, landmarks, {
              color: "#FF0000",
              lineWidth: 1,
              radius: 3,
            });

            // 핵심 포인트 시각화
            const wrist = landmarks[0]; // 손목
            const indexMCP = landmarks[5]; // 검지 뿌리
            const pinkyMCP = landmarks[17]; // 새끼 뿌리

            // 좌표 변환 (0~1 -> 픽셀)
            const wX = wrist.x * canvasElement.width;
            const wY = wrist.y * canvasElement.height;
            const iX = indexMCP.x * canvasElement.width;
            const iY = indexMCP.y * canvasElement.height;
            const pX = pinkyMCP.x * canvasElement.width;
            const pY = pinkyMCP.y * canvasElement.height;

            // 손목 타겟 (파란 원)
            canvasCtx.beginPath();
            canvasCtx.arc(wX, wY, 10, 0, 2 * Math.PI);
            canvasCtx.fillStyle = "cyan";
            canvasCtx.fill();
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = "white";
            canvasCtx.stroke();

            // 너비 가이드 (노란 선)
            canvasCtx.beginPath();
            canvasCtx.moveTo(iX, iY);
            canvasCtx.lineTo(pX, pY);
            canvasCtx.strokeStyle = "yellow";
            canvasCtx.lineWidth = 4;
            canvasCtx.stroke();
          }
        }
        canvasCtx.restore();
      }

      // MediaPipe Hands 초기화
      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        },
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      hands.onResults(onResults);

      // 카메라 시작 함수 (navigator.mediaDevices 사용)
      async function startCamera() {
        try {
          // 후면 카메라 요청 설정
          const constraints = {
            video: {
              facingMode: { ideal: "environment" }, // 후면 카메라 선호
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
          };

          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          videoElement.srcObject = stream;

          // 비디오 메타데이터 로드 후 처리
          videoElement.onloadedmetadata = () => {
            videoElement.play();
            processVideo(); // 프레임 처리 루프 시작
          };
        } catch (error) {
          console.error("Error accessing camera:", error);
          loadingText.innerText = "Camera Error: " + error.message;
        }
      }

      // 프레임 처리 루프
      async function processVideo() {
        if (videoElement.paused || videoElement.ended) {
          return;
        }
        // 현재 비디오 프레임을 MediaPipe로 전송
        await hands.send({ image: videoElement });

        // 다음 프레임 요청
        requestAnimationFrame(processVideo);
      }

      // 실행
      startCamera();
    </script>
  </body>
</html>
